diff --git mlibc-clean/sysdeps/vinix/generic/entry.cpp mlibc-workdir/sysdeps/vinix/generic/entry.cpp
index 5cf1f7b..d9f8724 100644
--- mlibc-clean/sysdeps/vinix/generic/entry.cpp
+++ mlibc-workdir/sysdeps/vinix/generic/entry.cpp
@@ -112,7 +112,7 @@ static void __mlibc_sigentry(int which, siginfo_t *siginfo,
 }
 
 extern "C" void __mlibc_entry(int (*main_fn)(int argc, char *argv[], char *env[])) {
-	mlibc::sys_sigentry((void *)__mlibc_sigentry);
+	//mlibc::sys_sigentry((void *)__mlibc_sigentry);
 
 	// TODO: call __dlapi_enter, otherwise static builds will break (see Linux sysdeps)
 	auto result = main_fn(__mlibc_stack_data.argc, __mlibc_stack_data.argv, environ);
diff --git mlibc-clean/sysdeps/vinix/generic/generic.cpp mlibc-workdir/sysdeps/vinix/generic/generic.cpp
index 1722935..d833a89 100644
--- mlibc-clean/sysdeps/vinix/generic/generic.cpp
+++ mlibc-workdir/sysdeps/vinix/generic/generic.cpp
@@ -7,18 +7,21 @@
 #include <limits.h>
 #include <asm/ioctls.h>
 #include <stdlib.h>
+#include <abi-bits/fcntl.h>
 
 #include "syscall.h"
 
-#define STUB_ONLY {                             \
-	__ensure(!"STUB_ONLY function was called"); \
-	__builtin_unreachable();                    \
+#define STRINGIFY_(X) #X
+#define STRINGIFY(X) STRINGIFY_(X)
+#define STUB_ONLY { \
+	sys_libc_log("STUB_ONLY function on line " STRINGIFY(__LINE__) " was called"); \
+	sys_libc_panic(); \
 }
 
 namespace mlibc {
 
 void sys_libc_log(const char *message) {
-	__syscall(0, message);
+	__syscall(SYS_debug, message);
 }
 
 void sys_libc_panic() {
@@ -28,18 +31,11 @@ void sys_libc_panic() {
 }
 
 void sys_exit(int status) {
-	__syscall(15, status);
+	for (;;);
 	__builtin_unreachable();
 }
 
-int sys_kill(pid_t pid, int signal) {
-	__syscall_ret ret = __syscall(26, pid, signal);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	return 0;
-}
+int sys_kill(pid_t pid, int signal) STUB_ONLY
 
 int sys_tcgetattr(int fd, struct termios *attr) {
 	int ret;
@@ -73,193 +69,58 @@ int sys_tcsetattr(int fd, int optional_action, const struct termios *attr) {
 }
 
 int sys_tcb_set(void *pointer) {
-	__syscall(7, pointer);
+	__syscall(SYS_set_fs_base, pointer);
 	return 0;
 }
 
 int sys_ppoll(struct pollfd *fds, int nfds, const struct timespec *timeout,
-		const sigset_t *sigmask, int *num_events) {
-	__syscall_ret ret = __syscall(36, fds, nfds, timeout, sigmask);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	*num_events = (int)ret.ret;
-	return 0;
-}
+		const sigset_t *sigmask, int *num_events) STUB_ONLY
 
-int sys_poll(struct pollfd *fds, nfds_t count, int timeout, int *num_events) {
-	struct timespec ts;
-	ts.tv_sec = timeout / 1000;
-	ts.tv_nsec = (timeout % 1000) * 1000000;
-	return sys_ppoll(fds, count, &ts, NULL, num_events);
-}
+int sys_poll(struct pollfd *fds, nfds_t count, int timeout, int *num_events) STUB_ONLY
 
 int sys_epoll_pwait(int epfd, struct epoll_event *ev, int n,
-					int timeout, const sigset_t *sigmask, int *raised) {
-	__syscall_ret ret = __syscall(49, epfd, ev, n, timeout, sigmask);
+					int timeout, const sigset_t *sigmask, int *raised) STUB_ONLY
 
-	if (ret.errno != 0)
-		return ret.errno;
+int sys_epoll_create(int flags, int *fd) STUB_ONLY
 
-	*raised = (int)ret.ret;
-	return 0;
-}
-
-int sys_epoll_create(int flags, int *fd) {
-	__syscall_ret ret = __syscall(37, flags);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	*fd = (int)ret.ret;
-	return 0;
-}
-
-int sys_epoll_ctl(int epfd, int mode, int fd, struct epoll_event *ev) {
-	__syscall_ret ret = __syscall(47, epfd, mode, fd, ev);
-
-	return ret.errno;
-}
+int sys_epoll_ctl(int epfd, int mode, int fd, struct epoll_event *ev) STUB_ONLY
 
 #ifndef MLIBC_BUILDING_RTDL
 int sys_pselect(int nfds, fd_set *read_set, fd_set *write_set,
 		fd_set *except_set, const struct timespec *timeout,
 		const sigset_t *sigmask, int *num_events) {
-	struct pollfd *fds = (struct pollfd *)malloc(nfds * sizeof(struct pollfd));
-
-	for (int i = 0; i < nfds; i++) {
-		struct pollfd *fd = &fds[i];
-		memset(fd, 0, sizeof(struct pollfd));
-
-		if (read_set && FD_ISSET(i, read_set))
-			fd->events |= POLLIN; // TODO: Additional events.
-		if (write_set && FD_ISSET(i, write_set))
-			fd->events |= POLLOUT; // TODO: Additional events.
-		if (except_set && FD_ISSET(i, except_set))
-			fd->events |= POLLPRI;
-
-		if (!fd->events) {
-			fd->fd = -1;
-			continue;
-		}
-
-		fd->fd = i;
-	}
-
-	int e = sys_ppoll(fds, nfds, timeout, sigmask, num_events);
-
-	if (e != 0) {
-		free(fds);
-		return e;
-	}
-
-	fd_set res_read_set;
-	fd_set res_write_set;
-	fd_set res_except_set;
-	FD_ZERO(&res_read_set);
-	FD_ZERO(&res_write_set);
-	FD_ZERO(&res_except_set);
-
-	for (int i = 0; i < nfds; i++) {
-		struct pollfd *fd = &fds[i];
-
-		if (read_set && FD_ISSET(i, read_set)
-				&& fd->revents & (POLLIN | POLLERR | POLLHUP)) {
-			FD_SET(i, &res_read_set);
-		}
-
-		if (write_set && FD_ISSET(i, write_set)
-				&& fd->revents & (POLLOUT | POLLERR | POLLHUP)) {
-			FD_SET(i, &res_write_set);
-		}
-
-		if (except_set && FD_ISSET(i, except_set)
-				&& fd->revents & POLLPRI) {
-			FD_SET(i, &res_except_set);
-		}
-	}
-
-	free(fds);
-
-	if (read_set)
-		memcpy(read_set, &res_read_set, sizeof(fd_set));
-	if (write_set)
-		memcpy(write_set, &res_write_set, sizeof(fd_set));
-	if (except_set)
-		memcpy(except_set, &res_except_set, sizeof(fd_set));
-
+	*num_events = 0;
 	return 0;
 }
 #endif
 
-int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
-	__syscall_ret ret = __syscall(23, pointer, expected, time);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	return 0;
-}
-
-int sys_futex_wake(int *pointer) {
-	__syscall_ret ret = __syscall(24, pointer);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	int num_woken = ret.ret;
+int sys_futex_wait(int *pointer, int expected, const struct timespec *time) STUB_ONLY
 
-	__ensure(num_woken >= 0 && num_woken <= 1);
-	return num_woken;
-}
+int sys_futex_wake(int *pointer) STUB_ONLY
 
-int sys_timerfd_create(int flags, int *fd) {
-	__syscall_ret ret = __syscall(54, 0, flags);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	*fd = (int)ret.ret;
-	return 0;
-}
+int sys_timerfd_create(int flags, int *fd) STUB_ONLY
 
 int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
-	__syscall_ret ret = __syscall(9, fd, request, arg);
-
-	if (ret.errno != 0)
+	__syscall_ret ret = __syscall(SYS_ioctl, fd, request, arg);
+	if (ret.ret == -1) {
 		return ret.errno;
-
+	}
 	*result = (int)ret.ret;
 	return 0;
 }
 
 int sys_isatty(int fd) {
-	struct winsize ws;
-	int ret;
-
-	if (!sys_ioctl(fd, TIOCGWINSZ, &ws, &ret))
-		return 0;
-
-	return ENOTTY;
+    return 0;
 }
 
-int sys_getcwd(char *buffer, size_t size) {
-	__syscall_ret ret = __syscall(25, buffer, size);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	return 0;
-}
+int sys_getcwd(char *buffer, size_t size) STUB_ONLY
 
 int sys_openat(int dirfd, const char *path, int flags, int *fd) {
-	__syscall_ret ret = __syscall(2, dirfd, path, flags, 0);
-
-	if (ret.errno != 0)
+	__syscall_ret ret = __syscall(SYS_openat, dirfd, path, flags, 0);
+	if (ret.ret == -1) {
 		return ret.errno;
-
-	*fd = (int)ret.ret;
+	}
+	*fd = ret.ret;
 	return 0;
 }
 
@@ -267,622 +128,259 @@ int sys_open(const char *path, int flags, mode_t, int *fd) {
 	return sys_openat(AT_FDCWD, path, flags, fd);
 }
 
-int sys_open_dir(const char *path, int *handle) {
-	return sys_open(path, O_DIRECTORY, 0, handle);
-}
-
-int sys_read_entries(int fd, void *buffer, size_t max_size, size_t *bytes_read) {
-	(void)max_size;
-	__syscall_ret ret = __syscall(19, fd, buffer);
+int sys_open_dir(const char *path, int *handle) STUB_ONLY
 
-	if (ret.ret == (uint64_t)-1 && ret.errno == 0) {
-		// End of directory.
-		*bytes_read = 0;
-		return 0;
-	} else if (ret.errno != 0) {
-		return ret.errno;
-	}
-
-	*bytes_read = sizeof(struct dirent);
-	return 0;
-}
+int sys_read_entries(int fd, void *buffer, size_t max_size, size_t *bytes_read) STUB_ONLY
 
 int sys_close(int fd) {
-	__syscall_ret ret = __syscall(6, fd);
-
-	if (ret.errno != 0)
+	__syscall_ret ret = __syscall(SYS_close, fd);
+	if (ret.ret == -1) {
 		return ret.errno;
-
+	}
 	return 0;
 }
 
 int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
-	__syscall_ret ret = __syscall(5, fd, offset, whence);
-
-	if (ret.errno != 0) {
+	__syscall_ret ret = __syscall(SYS_seek, fd, offset, whence);
+	if (ret.ret == -1) {
 		return ret.errno;
 	}
-
 	*new_offset = (off_t)ret.ret;
 	return 0;
 }
 
 int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
-	__syscall_ret ret = __syscall(3, fd, buf, count);
-
-	if (ret.errno != 0) {
+	__syscall_ret ret = __syscall(SYS_read, fd, buf, count);
+	if (ret.ret == -1) {
 		return ret.errno;
 	}
-
 	*bytes_read = (ssize_t)ret.ret;
 	return 0;
 }
 
 int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) {
-	__syscall_ret ret = __syscall(4, fd, buf, count);
-
-	if (ret.errno != 0) {
+	__syscall_ret ret = __syscall(SYS_write, fd, buf, count);
+	if (ret.ret == -1) {
 		return ret.errno;
 	}
-
 	*bytes_written = (ssize_t)ret.ret;
 	return 0;
 }
 
-int sys_readlink(const char *path, void *data, size_t max_size, ssize_t *length) {
-	__syscall_ret ret = __syscall(33, AT_FDCWD, path, data, max_size);
+int sys_readlink(const char *path, void *data, size_t max_size, ssize_t *length) STUB_ONLY
 
-	if (ret.errno != 0) {
-		return ret.errno;
-	}
+int sys_link(const char *old_path, const char *new_path) STUB_ONLY
 
-	*length = (ssize_t)ret.ret;
-	return 0;
-}
+int sys_linkat(int olddirfd, const char *old_path, int newdirfd, const char *new_path, int flags) STUB_ONLY
 
-int sys_link(const char *old_path, const char *new_path) {
-	return sys_linkat(AT_FDCWD, old_path, AT_FDCWD, new_path, 0);
-}
+int sys_unlinkat(int fd, const char *path, int flags) STUB_ONLY
 
-int sys_linkat(int olddirfd, const char *old_path, int newdirfd, const char *new_path, int flags) {
-	__syscall_ret ret = __syscall(58, olddirfd, old_path, newdirfd, new_path, flags);
+int sys_fchmod(int fd, mode_t mode) STUB_ONLY
 
-	if (ret.errno != 0) {
-		return ret.errno;
-	}
-
-	return 0;
-}
-
-int sys_unlinkat(int fd, const char *path, int flags) {
-	__syscall_ret ret = __syscall(35, fd, path, flags);
-
-	if (ret.errno != 0) {
-		return ret.errno;
-	}
-
-	return 0;
-}
-
-int sys_fchmod(int fd, mode_t mode) {
-	__syscall_ret ret = __syscall(57, fd, mode);
-
-	if (ret.errno != 0) {
-		return ret.errno;
-	}
-
-	return 0;
-}
-
-int sys_rmdir(const char *path) {
-	(void)path;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return 0;
-}
+int sys_rmdir(const char *path) STUB_ONLY
 
 int sys_vm_map(void *hint, size_t size, int prot, int flags,
 			   int fd, off_t offset, void **window) {
-	__syscall_ret ret = __syscall(1, hint, size,
-								  (uint64_t)prot << 32 | (uint64_t)flags, fd, offset);
-	if (ret.errno != 0)
+	__syscall_ret ret = __syscall(SYS_mmap, hint, size, (uint64_t)prot << 32 | flags,
+								  fd, offset);
+    if ((void *)ret.ret == MAP_FAILED) {
 		return ret.errno;
-
+	}
 	*window = (void *)ret.ret;
 	return 0;
 }
 
-int sys_vm_unmap(void *pointer, size_t size) {
-	__syscall_ret ret = __syscall(34, pointer, size);
+int sys_vm_unmap(void *pointer, size_t size) STUB_ONLY
 
-	if (ret.errno != 0)
-		return ret.errno;
-
-	return 0;
-}
-
-int sys_vm_protect(void *pointer, size_t size, int prot) {
-	__syscall_ret ret = __syscall(48, pointer, size, prot);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	return 0;
-}
+int sys_vm_protect(void *pointer, size_t size, int prot) STUB_ONLY
 
 int sys_anon_allocate(size_t size, void **pointer) {
-	return sys_vm_map(NULL, size, PROT_EXEC | PROT_READ | PROT_WRITE,
-					  MAP_ANONYMOUS, -1, 0, pointer);
+	return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS, -1, 0, pointer);
 }
 
-int sys_anon_free(void *pointer, size_t size) {
-	(void)pointer; (void)size;
-	return 0;
-}
+int sys_anon_free(void *pointer, size_t size) STUB_ONLY
 
 pid_t sys_getpid() {
-	__syscall_ret ret = __syscall(31);
-
-	return ret.ret;
+    __syscall_ret ret = __syscall(SYS_getpid);
+    return ret.ret;
 }
 
 pid_t sys_getppid() {
-	__syscall_ret ret = __syscall(32);
-
-	return ret.ret;
+    return 0;
 }
 
 uid_t sys_getuid() {
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return 0;
+    return 0;
 }
 
 uid_t sys_geteuid() {
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return 0;
+    return 0;
 }
 
 gid_t sys_getgid() {
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return 0;
+    return 0;
 }
 
 int sys_setgid(gid_t gid) {
-	(void)gid;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return 0;
+    return 0;
 }
 
 pid_t sys_getpgid(pid_t pid, pid_t *pgid) {
-	(void)pid;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	*pgid = 0;
-	return 0;
+    return 0;
 }
 
 gid_t sys_getegid() {
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return 0;
+    return 0;
 }
 
 int sys_setpgid(pid_t pid, pid_t pgid) {
-	(void)pid; (void)pgid;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return 0;
+    return 0;
 }
 
 int sys_ttyname(int fd, char *buf, size_t size) {
-	(void)fd; (void)buf; (void)size;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return ENOSYS;
+    return ENOSYS;
 }
 
 int sys_clock_get(int clock, time_t *secs, long *nanos) {
-	struct timespec ts;
-	__syscall_ret ret = __syscall(50, clock, &ts);
-
-	if (ret.errno != 0) {
-		return ret.errno;
-	}
-
-	*secs = ts.tv_sec;
-	*nanos = ts.tv_nsec;
-
-	return 0;
+    *secs = 0;
+    *nanos = 0;
+    return 0;
 }
 
 int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf) {
+	__syscall_ret ret;
 	switch (fsfdt) {
-		case fsfd_target::fd: {
-			__syscall_ret ret = __syscall(10, fd, statbuf);
-			if (ret.errno != 0)
-				return ret.errno;
-			return ret.ret;
-		}
-		case fsfd_target::path: {
-			__syscall_ret ret = __syscall(11, AT_FDCWD, path, statbuf, flags);
-			if (ret.errno != 0)
-				return ret.errno;
-			return ret.ret;
-		}
-		case fsfd_target::fd_path: {
-			__syscall_ret ret = __syscall(11, fd, path, statbuf, flags);
-			if (ret.errno != 0)
-				return ret.errno;
-			return ret.ret;
-		}
-		default: {
-			__ensure(!"stat: Invalid fsfdt");
+		case fsfd_target::fd:
+			ret = __syscall(SYS_stat, fd, "", flags | AT_EMPTY_PATH, statbuf);
+			break;
+		case fsfd_target::path:
+			ret = __syscall(SYS_stat, AT_FDCWD, path, flags, statbuf);
+			break;
+		case fsfd_target::fd_path:
+			ret = __syscall(SYS_stat, fd, path, flags, statbuf);
+			break;
+		default:
+			__ensure(!"sys_stat: Invalid fsfdt");
 			__builtin_unreachable();
-		}
 	}
-	return 0;
-}
-
-int sys_faccessat(int dirfd, const char *pathname, int mode, int flags) {
-	__syscall_ret ret = __syscall(20, dirfd, pathname, mode, flags);
-
-	if (ret.errno != 0) {
-		return ret.errno;
-	}
-
-	return 0;
-}
-
-int sys_access(const char *path, int mode) {
-	return sys_faccessat(AT_FDCWD, path, mode, 0);
-}
-
-int sys_pipe(int *fds, int flags) {
-	__syscall_ret ret = __syscall(21, fds, flags);
-
-	if (ret.errno != 0) {
+	if (ret.ret == -1) {
 		return ret.errno;
 	}
-
 	return 0;
 }
 
-int sys_chdir(const char *path) {
-	__syscall_ret ret = __syscall(18, path);
-
-	if (ret.errno != 0) {
-		return ret.errno;
-	}
-
-	return 0;
+int sys_faccessat(int dirfd, const char *pathname, int mode, int flags) {
+    return ENOSYS;
 }
 
-int sys_mkdir(const char *path, mode_t mode) {
-	return sys_mkdirat(AT_FDCWD, path, mode);
+int sys_access(const char *path, int mode) {
+    return ENOSYS;
 }
 
-int sys_mkdirat(int dirfd, const char *path, mode_t mode) {
-	__syscall_ret ret = __syscall(22, dirfd, path, mode);
+int sys_pipe(int *fds, int flags) STUB_ONLY
 
-	return ret.errno;
-}
+int sys_chdir(const char *path) STUB_ONLY
 
-int sys_socket(int domain, int type_and_flags, int proto, int *fd) {
-	__syscall_ret ret = __syscall(39, domain, type_and_flags, proto);
+int sys_mkdir(const char *path, mode_t mode) STUB_ONLY
 
-	if (ret.errno != 0)
-		return ret.errno;
+int sys_mkdirat(int dirfd, const char *path, mode_t mode) STUB_ONLY
 
-	*fd = (int)ret.ret;
-	return 0;
-}
+int sys_socket(int domain, int type_and_flags, int proto, int *fd) STUB_ONLY
 
-int sys_socketpair(int domain, int type_and_flags, int proto, int *fds) {
-	__syscall_ret ret = __syscall(46, domain, type_and_flags, proto, fds);
+int sys_socketpair(int domain, int type_and_flags, int proto, int *fds) STUB_ONLY
 
-	return ret.errno;
-}
-
-int sys_bind(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) {
-	__syscall_ret ret = __syscall(40, fd, addr_ptr, addr_length);
-
-	return ret.errno;
-}
+int sys_bind(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) STUB_ONLY
 
-int sys_connect(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) {
-	__syscall_ret ret = __syscall(59, fd, addr_ptr, addr_length);
+int sys_connect(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) STUB_ONLY
 
-	return ret.errno;
-}
-
-int sys_accept(int fd, int *newfd, struct sockaddr *addr_ptr, socklen_t *addr_length) {
-	__syscall_ret ret = __syscall(61, fd);
-
-	if (ret.errno != 0) {
-		return ret.errno;
-	}
-
-	*newfd = ret.ret;
-
-	if(addr_ptr && addr_length) {
-		if(int e = mlibc::sys_peername(*newfd, addr_ptr, *addr_length, addr_length); e) {
-			return e;
-		}
-	}
-
-	return 0;
-}
+int sys_accept(int fd, int *newfd, struct sockaddr *addr_ptr, socklen_t *addr_length) STUB_ONLY
 
 int sys_getsockopt(int fd, int layer, int number,
-		void *__restrict buffer, socklen_t *__restrict size) {
-	(void)fd; (void)size;
-	if(layer == SOL_SOCKET && number == SO_PEERCRED) {
-		mlibc::infoLogger() << "\e[31mmlibc: getsockopt() call with SOL_SOCKET and SO_PEERCRED is unimplemented\e[39m" << frg::endlog;
-		*(int *)buffer = 0;
-		return 0;
-	}else if(layer == SOL_SOCKET && number == SO_SNDBUF) {
-		mlibc::infoLogger() << "\e[31mmlibc: getsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented\e[39m" << frg::endlog;
-		*(int *)buffer = 4096;
-		return 0;
-	}else if(layer == SOL_SOCKET && number == SO_TYPE) {
-		mlibc::infoLogger() << "\e[31mmlibc: getsockopt() call with SOL_SOCKET and SO_TYPE is unimplemented, hardcoding SOCK_STREAM\e[39m" << frg::endlog;
-		*(int *)buffer = SOCK_STREAM;
-		return 0;
-	}else if(layer == SOL_SOCKET && number == SO_ERROR) {
-		mlibc::infoLogger() << "\e[31mmlibc: getsockopt() call with SOL_SOCKET and SO_ERROR is unimplemented, hardcoding 0\e[39m" << frg::endlog;
-		*(int *)buffer = 0;
-		return 0;
-	}else if(layer == SOL_SOCKET && number == SO_KEEPALIVE) {
-		mlibc::infoLogger() << "\e[31mmlibc: getsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented, hardcoding 0\e[39m" << frg::endlog;
-		*(int *)buffer = 0;
-		return 0;
-	}else{
-		mlibc::panicLogger() << "\e[31mmlibc: Unexpected getsockopt() call, layer: " << layer << " number: " << number << "\e[39m" << frg::endlog;
-		__builtin_unreachable();
-	}
-
-	return 0;
-}
-
+		void *__restrict buffer, socklen_t *__restrict size) STUB_ONLY
 
 int sys_setsockopt(int fd, int layer, int number,
-		const void *buffer, socklen_t size) {
-	(void)fd; (void)buffer; (void)size;
-	if(layer == SOL_SOCKET && number == SO_PASSCRED) {
-		mlibc::infoLogger() << "\e[31mmlibc: setsockopt(SO_PASSCRED) is not implemented"
-				" correctly\e[39m" << frg::endlog;
-		return 0;
-	}else if(layer == SOL_SOCKET && number == SO_ATTACH_FILTER) {
-		mlibc::infoLogger() << "\e[31mmlibc: setsockopt(SO_ATTACH_FILTER) is not implemented"
-				" correctly\e[39m" << frg::endlog;
-		return 0;
-	}else if(layer == SOL_SOCKET && number == SO_RCVBUFFORCE) {
-		mlibc::infoLogger() << "\e[31mmlibc: setsockopt(SO_RCVBUFFORCE) is not implemented"
-				" correctly\e[39m" << frg::endlog;
-		return 0;
-	}else if(layer == SOL_SOCKET && number == SO_SNDBUF) {
-		mlibc::infoLogger() << "\e[31mmlibc: setsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented\e[39m" << frg::endlog;
-		return 0;
-	}else if(layer == SOL_SOCKET && number == SO_KEEPALIVE) {
-		mlibc::infoLogger() << "\e[31mmlibc: setsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented\e[39m" << frg::endlog;
-		return 0;
-	}else if(layer == SOL_SOCKET && number == SO_REUSEADDR) {
-		mlibc::infoLogger() << "\e[31mmlibc: setsockopt() call with SOL_SOCKET and SO_REUSEADDR is unimplemented\e[39m" << frg::endlog;
-		return 0;
-	}else if(layer == AF_NETLINK && number == SO_ACCEPTCONN) {
-		mlibc::infoLogger() << "\e[31mmlibc: setsockopt() call with AF_NETLINK and SO_ACCEPTCONN is unimplemented\e[39m" << frg::endlog;
-		return 0;
-	}else{
-		mlibc::panicLogger() << "\e[31mmlibc: Unexpected setsockopt() call, layer: " << layer << " number: " << number << "\e[39m" << frg::endlog;
-		__builtin_unreachable();
-	}
-}
-
-int sys_msg_recv(int sockfd, struct msghdr *hdr, int flags, ssize_t *length) {
-	__syscall_ret ret = __syscall(62, sockfd, hdr, flags);
-
-	if (ret.errno != 0) {
-		return ret.errno;
-	}
+		const void *buffer, socklen_t size) STUB_ONLY
 
-	*length = (ssize_t)ret.ret;
-	return 0;
-}
+int sys_msg_recv(int sockfd, struct msghdr *hdr, int flags, ssize_t *length) STUB_ONLY
 
-int sys_peername(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) {
-	__syscall_ret ret = __syscall(60, fd, addr_ptr, &max_addr_length);
-
-	if (ret.errno != 0) {
-		return ret.errno;
-	}
-
-	*actual_length = max_addr_length;
-	return 0;
-}
+int sys_peername(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) STUB_ONLY
 
-int sys_listen(int fd, int backlog) {
-	__syscall_ret ret = __syscall(41, fd, backlog);
+int sys_listen(int fd, int backlog) STUB_ONLY
 
-	return ret.errno;
-}
-
-int sys_inotify_create(int flags, int *fd) {
-	__syscall_ret ret = __syscall(42, flags);
-
-	if (ret.errno != 0) {
-		return ret.errno;
-	}
-
-	*fd = (int)ret.ret;
-	return 0;
-}
+int sys_inotify_create(int flags, int *fd) STUB_ONLY
 
 int sys_fork(pid_t *child) {
-	__syscall_ret ret = __syscall(14);
-
-	if (ret.errno != 0) {
+	__syscall_ret ret = __syscall(SYS_fork);
+    if (ret.ret == -1) {
 		return ret.errno;
 	}
-
 	*child = (pid_t)ret.ret;
 	return 0;
 }
 
 int sys_execve(const char *path, char *const argv[], char *const envp[]) {
-	__syscall_ret ret = __syscall(17, path, argv, envp);
-
-	return ret.errno;
+	__syscall_ret ret = __syscall(SYS_exec, path, argv, envp);
+    return ret.errno;
 }
 
 int sys_fcntl(int fd, int request, va_list args, int *result) {
-	__syscall_ret ret = __syscall(12, fd, request, va_arg(args, uint64_t));
-
-	if (ret.errno != 0)
+	__syscall_ret ret = __syscall(SYS_fcntl, fd, request, va_arg(args, uint64_t));
+    if (ret.ret == -1) {
 		return ret.errno;
-
-	*result = (ssize_t)ret.ret;
+	}
+	*result = (int)ret.ret;
 	return 0;
 }
 
 int sys_dup(int fd, int flags, int *newfd) {
-	(void)flags;
-	__syscall_ret ret = __syscall(12, fd, F_DUPFD, 0);
-
-	if (ret.errno != 0)
+	__syscall_ret ret = __syscall(SYS_fcntl, fd, F_DUPFD, 0);
+    if (ret.ret == -1) {
 		return ret.errno;
-
-	*newfd = (ssize_t)ret.ret;
+	}
+	*newfd = (int)ret.ret;
 	return 0;
 }
 
 int sys_dup2(int fd, int flags, int newfd) {
-	__syscall_ret ret = __syscall(13, fd, newfd, flags);
-
-	if (ret.errno != 0)
+	__syscall_ret ret = __syscall(SYS_dup3, fd, newfd, flags);
+    if (ret.ret == -1) {
 		return ret.errno;
-
+	}
 	return 0;
 }
 
 int sys_sigprocmask(int how, const sigset_t *__restrict set, sigset_t *__restrict retrieve) {
-	__syscall_ret ret = __syscall(28, how, set, retrieve);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	return 0;
+    return ENOSYS;
 }
 
 int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {
-	__syscall_ret ret = __syscall(29, signum, act, oldact);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	return 0;
+    return ENOSYS;
 }
 
-int sys_signalfd_create(sigset_t mask, int flags, int *fd) {
-	__syscall_ret ret = __syscall(45, *fd, mask, flags);
-
-	if (ret.errno != 0)
-		return ret.errno;
+int sys_signalfd_create(sigset_t mask, int flags, int *fd) STUB_ONLY
 
-	*fd = (int)ret.ret;
-	return 0;
-}
-
-int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid) {
-	if(ru) {
-		mlibc::infoLogger() << "mlibc: struct rusage in sys_waitpid is unsupported" << frg::endlog;
-		return ENOSYS;
-	}
+int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid) STUB_ONLY
 
-again:
-	__syscall_ret ret = __syscall(16, pid, status, flags);
+int sys_getgroups(size_t size, const gid_t *list, int *_ret) STUB_ONLY
 
-	if (ret.errno != 0) {
-		if (ret.errno == EINTR) {
-			goto again;
-		}
+int sys_mount(const char *source, const char *target, const char *fstype, unsigned long flags, const void *data) STUB_ONLY
 
-		return ret.errno;
-	}
-
-	*ret_pid = (pid_t)ret.ret;
-	return 0;
-}
-
-int sys_getgroups(size_t size, const gid_t *list, int *_ret) {
-	__syscall_ret ret = __syscall(38, size, list);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	*_ret = (int)ret.ret;
-	return 0;
-}
-
-int sys_mount(const char *source, const char *target, const char *fstype, unsigned long flags, const void *data) {
-	__syscall_ret ret = __syscall(43, source, target, fstype, flags, data);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	return 0;
-}
-
-int sys_umount2(const char *target, int flags) {
-	__syscall_ret ret = __syscall(44, target, flags);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	return 0;
-}
+int sys_umount2(const char *target, int flags) STUB_ONLY
 
 int sys_gethostname(char *buffer, size_t bufsize) {
-	__syscall_ret ret = __syscall(51, buffer, bufsize);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	return 0;
+    return ENOSYS;
 }
 
-int sys_sethostname(const char *buffer, size_t bufsize) {
-	__syscall_ret ret = __syscall(52, buffer, bufsize);
-
-	if (ret.errno != 0)
-		return ret.errno;
-
-	return 0;
-}
-
-int sys_sleep(time_t *secs, long *nanos) {
-	struct timespec req = {
-		.tv_sec = *secs,
-		.tv_nsec = *nanos
-	};
-	struct timespec rem = {0, 0};
-
-	__syscall_ret ret = __syscall(53, &req, &rem);
+int sys_sethostname(const char *buffer, size_t bufsize) STUB_ONLY
 
-	if (ret.errno != 0)
-		return ret.errno;
-
-	*secs = rem.tv_sec;
-	*nanos = rem.tv_nsec;
-	return 0;
-}
-
-
-int sys_getitimer(int which, struct itimerval *curr_value) {
-	__syscall_ret ret = __syscall(63, which, curr_value);
-
-	return ret.errno;
-}
+int sys_sleep(time_t *secs, long *nanos) STUB_ONLY
 
+int sys_getitimer(int which, struct itimerval *curr_value) STUB_ONLY
 
-int sys_setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value) {
-	__syscall_ret ret = __syscall(64, which, new_value, old_value);
+int sys_setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value) STUB_ONLY
 
-	return ret.errno;
+int sys_umask(mode_t mode, mode_t *old) {
+    return ENOSYS;
 }
 
 } // namespace mlibc
diff --git mlibc-clean/sysdeps/vinix/generic/syscall.h mlibc-workdir/sysdeps/vinix/generic/syscall.h
index f421220..584ffc9 100644
--- mlibc-clean/sysdeps/vinix/generic/syscall.h
+++ mlibc-workdir/sysdeps/vinix/generic/syscall.h
@@ -1,16 +1,74 @@
 #include <stdint.h>
 
+#define SYS_debug 0
+#define SYS_mmap 1
+#define SYS_openat 2
+#define SYS_close 3
+#define SYS_read 4
+#define SYS_write 5
+#define SYS_seek 6
+#define SYS_set_fs_base 7
+#define SYS_set_gs_base 8
+#define SYS_stat 9
+#define SYS_fcntl 10
+#define SYS_dup3 11
+#define SYS_ioctl 12
+#define SYS_fork 13
+#define SYS_exec 14
+#define SYS_getpid 15
+
 struct __syscall_ret {
 	uint64_t ret;
 	uint64_t errno;
 };
 
-__attribute__((naked))
-static __syscall_ret __syscall(int number, ...) {
-	asm (
-		"mov %rcx, %r10\n\t"
-		"syscall\n\t"
-		"ret"
-	);
-	(void)number;
+#define __SYSCALL_EXPAND(...) \
+    struct __syscall_ret ret; \
+	asm volatile ( \
+		"mov %%rsp, %%r10\n\t" \
+		"lea 1f(%%rip), %%r11\n\t" \
+		"sysenter\n\t" \
+		"1:" \
+		: "=a"(ret.ret), "=b"(ret.errno) __VA_ARGS__ \
+		: "r10", "r11", "memory" \
+	); \
+	return ret
+
+static inline struct __syscall_ret __syscall5(int number, uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e) {
+    register uint64_t r8 asm("%r8") = d;
+    register uint64_t r9 asm("%r9") = e;
+    __SYSCALL_EXPAND(, "+d"(b), "+c"(c) : "D"(number), "S"(a), "r"(r8), "r"(r9));
+}
+
+static inline struct __syscall_ret __syscall4(int number, uint64_t a, uint64_t b, uint64_t c, uint64_t d) {
+    register uint64_t r8 asm("%r8") = d;
+    __SYSCALL_EXPAND(, "+d"(b), "+c"(c) : "D"(number), "S"(a), "r"(r8));
+}
+
+static inline struct __syscall_ret __syscall3(int number, uint64_t a, uint64_t b, uint64_t c) {
+    __SYSCALL_EXPAND(, "+d"(b), "+c"(c) : "D"(number), "S"(a));
+}
+
+static inline struct __syscall_ret __syscall2(int number, uint64_t a, uint64_t b) {
+    __SYSCALL_EXPAND(, "+d"(b) : "D"(number), "S"(a));
 }
+
+static inline struct __syscall_ret __syscall1(int number, uint64_t a) {
+    __SYSCALL_EXPAND( : "D"(number), "S"(a));
+}
+
+static inline struct __syscall_ret __syscall0(int number) {
+    __SYSCALL_EXPAND( : "D"(number));
+}
+
+#define __SYSCALL_NARGS_SEQ(_0,_1,_2,_3,_4,_5,_6,_7,N,...) N
+#define __SYSCALL_NARGS(...) __SYSCALL_NARGS_SEQ(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1, 0)
+
+#define __SYSCALL_CONCAT1(X, Y) X##Y
+#define __SYSCALL_CONCAT(X, Y) __SYSCALL_CONCAT1(X, Y)
+
+#define __syscall(...) ({ \
+    struct __syscall_ret (*__SYSCALL_f)(int, ...); \
+    __SYSCALL_f = (struct __syscall_ret (*)(int, ...))__SYSCALL_CONCAT(__syscall, __SYSCALL_NARGS(__VA_ARGS__)); \
+    __SYSCALL_f(__VA_ARGS__); \
+})
